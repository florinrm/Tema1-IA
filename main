from Cell import Cell
from Driver import Driver
from strategy import Strategies

from neinformalSearches.RideDepthFirstSearch import RideDepthFirstSearch
from neinformalSearches.RideBreadthFirstSearch import RideBreadthFirstSearch
from neinformalSearches.RideDepthLimitedSearch import RideDepthLimitedSearch
from neinformalSearches.RideIterativeDeepeningSearch import RideIterativeDeepeningSearch
from neinformalSearches.RideUniformCostSearch import RideUniformCostSearch

def parse_input(filename):
    file = open(filename, "r")
    tokens = list(file.readline().split(" "))

    height = int(tokens[0])
    width = int(tokens[1])
    capacity = int(tokens[2])

    tokens = list(file.readline().split(" "))

    carPositionY = int(tokens[0])
    carPositionX = int(tokens[1])

    tokens = list(file.readline().split(" "))
    n = int(tokens[0])

    clients = []
    for _ in range(n):
        tokens = list(file.readline().split(" "))
        startY = int(tokens[0])
        startX = int(tokens[1])
        destinationY = int(tokens[2])
        destinationX = int(tokens[3])
        budget = int(tokens[4])
        clients.append((startX, startY, destinationX, destinationY, budget))

    matrix = []

    file.readline()
    for i in range(height):
        line = file.readline().strip('\n')
        tokens = list(line.split(" "))
        row = []
        for j in range(width):
            cell = Cell(i, j, False, False)

            if j == 0:
                if tokens[j + 1] == ':':
                    cell.moveRight = True
            elif j == width - 1:
                if tokens[j] == ':':
                    cell.moveLeft = True
            else:
                if tokens[j] == ':':
                    cell.moveLeft = True
                if tokens[j + 1] == ':':
                    cell.moveRight = True

            row.append(cell)
        matrix.append(row)
    file.readline()

    driver = Driver(carPositionX, carPositionY, capacity, matrix)

    return (clients, driver)

def neinformalSearch(clients, driver, option):
    if option == Strategies.DepthFirstSearch:
        result = RideDepthFirstSearch(clients, driver)
        if result != False:
            return result
        else:
            print('failed')
            return False
    elif option == Strategies.BreadhFirstSearch:
        result = RideBreadthFirstSearch(clients, driver)
        if result != False:
            return result
        else:
            print('failed')
            return False
    elif option == Strategies.UniformCostSearch:
        result = RideUniformCostSearch(clients, driver)
        if result != False:
            return result
        else:
            print('failed')
            return False
    elif option == Strategies.IterativeDeepeningSearch:
        result = RideIterativeDeepeningSearch(clients, driver)
        if result != False:
            return result
        else:
            print('failed')
            return False
    elif option == Strategies.DepthLimitedSearch:
        result = RideDepthLimitedSearch(clients, driver, 10)
        if result != False:
            return result
        else:
            print('failed')
            return False
    elif option == Strategies.AStar:
        pass
    elif option == Strategies.GreedyBestFirstSearch:
        pass
    elif option == Strategies.HillClimbing:
        pass


def main():
    (clients, driver_initial_state) = parse_input("test1.in")
    result = neinformalSearch(clients, driver_initial_state, Strategies.UniformCostSearch)
    print(result)

if __name__ == '__main__':
    main()