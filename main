from Cell import Cell
from Driver import Driver
from strategy import Strategies

from algos.DepthLimitedSearch import DepthLimitedSearch
from algos.DepthFirstSearch import DepthFirstSearch
from algos.BreathFirstSearch import BreathFirstSearch
from algos.IterativeDeepeningSearch import IterativeDeepeningSearch
from algos.UniformCostSearch import UniformCostSearch
from algos.utils import g
import copy

def parse_input(filename):
    file = open(filename, "r")
    tokens = list(file.readline().split(" "))

    height = int(tokens[0])
    width = int(tokens[1])
    capacity = int(tokens[2])

    tokens = list(file.readline().split(" "))

    carPositionY = int(tokens[0])
    carPositionX = int(tokens[1])

    tokens = list(file.readline().split(" "))
    n = int(tokens[0])

    clients = []
    for _ in range(n):
        tokens = list(file.readline().split(" "))
        startY = int(tokens[0])
        startX = int(tokens[1])
        destinationY = int(tokens[2])
        destinationX = int(tokens[3])
        budget = int(tokens[4])
        clients.append((startX, startY, destinationX, destinationY, budget))

    matrix = []

    file.readline()
    for i in range(height):
        line = file.readline().strip('\n')
        tokens = list(line.split(" "))
        row = []
        for j in range(width):
            cell = Cell(i, j, False, False)

            if j == 0:
                if tokens[j + 1] == ':':
                    cell.moveRight = True
            elif j == width - 1:
                if tokens[j] == ':':
                    cell.moveLeft = True
            else:
                if tokens[j] == ':':
                    cell.moveLeft = True
                if tokens[j + 1] == ':':
                    cell.moveRight = True

            row.append(cell)
        matrix.append(row)
    file.readline()

    driver = Driver(carPositionX, carPositionY, capacity, matrix)

    return (clients, driver)

def neinformalSearch(clients, driver):
    state = copy.deepcopy(driver)
    for client in clients:
        # pick-up client
        state.destinationX = client[0] #startX client
        state.destinationY = client[1] #startY client

        budget = client[4]

        result = DepthFirstSearch(state, budget)
        if result != False:
            print(result)
        else:
            print('failed')
            return False

        #drop client
        result.destinationX = client[2]
        result.destinationX = client[3]

        final = DepthFirstSearch(state)
        if final != False:
            print(final)
        else:
            print('failed')
            return False


def main():
    (clients, driver_initial_state) = parse_input("test1.in")
    #print(driver)
    driver_initial_state.destinationX = 4
    driver_initial_state.destinationY = 4

    option = Strategies.BreadhFirstSearch

    if option == Strategies.DepthFirstSearch:
        result = DepthFirstSearch(driver_initial_state, 0)
        if result != False:
            print(result)
            print(g(result))
        else:
            print('failed')
    elif option == Strategies.BreadhFirstSearch:
        result = BreathFirstSearch(driver_initial_state, 69)
        if result != False:
            print(result)
            print(g(result))
        else:
            print('failed')
    elif option == Strategies.IterativeDeepeningSearch:
        result = IterativeDeepeningSearch(driver_initial_state, 0)
        if result != False:
            print(result)
        else:
            print('failed')
    elif option == Strategies.DepthLimitedSearch:
        result = DepthFirstSearch(driver_initial_state, 10)
        if result != False:
            print(result)
        else:
            print('failed')
    elif option == Strategies.UniformCostSearch:
        result = UniformCostSearch(driver_initial_state, 0)
        if result != False:
            print(result)
        else:
            print('failed')


if __name__ == '__main__':
    main()